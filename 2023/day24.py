# https://www.acmicpc.net/problem/2869
# 문제
# 땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.
# 달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.
# 달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B < A ≤ V ≤ 1,000,000,000)
# 출력
# 첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.

# V= 총 높이, A= 올라간 높이, B= 떨어진 높이
# 하루동안 올라간 높이는 A-B 정도
# 재귀함수로 하루하루 올라갔다 떨어졌다가 반복하게 만들어볼까?!

A, B, V = map(int, input().split())


def up(a, b, v, day):
    day += 1
    # 올라가기
    v = v-a
    # 올라 갔을 때 정상에 도달한다면
    if v == 0 or v < 0:
        return print(day)
    # 내려가기
    v = v+b
    return up(a, b, v, day)

# 재귀함수로 작성하였을 때 RecursionError가 발생하여서 while문으로 작성


def up(a, b, v):
    day = 0
    while True:
        day += 1
        # 올라가기
        v = v-a
        # 올라 갔을 때 정상에 도달한다면
        if v == 0 or v < 0:
            break
        # 내려가기
        v = v+b
    return print(day)

# 하지만 소요 시간이 너무 걸렸다. 그래서 최대 재귀 깊이를 변경하였으나 메모리 초과로 실패.
# 아무래도 반복문이나 재귀함수를 사용하지 않고 수학적으로 좀 더 접근해봐야할 것 같다.

# 조건을 세분화 해보자.
# 1. 올라간 높이가 총 높이보다 클 때 반환 값은 1
# 2. 올라간 높이가 총 높이보다 작을 때, 총 높이 나누기 하루동안 올라간 높이를 한다. 하지만 올라갔을 때 총 높이에 도달하면 다시 내려오지 않으므로 (총높이-올라간높이)/(하루동안 올라간 높이)를 해준다.
# 2-1. (총높이-올라간높이)/(하루동안 올라간 높이)에서 만약 나머지가 존재하지 않는다면 총높이-올라간높이를 빼줬으므로 +1을 해주고, 나머지가 존재한다면 하루 더 올라가야하므로 +2를 해준다.


# 최종 함수
A, B, V = map(int, input().split())

if A > V:
    print(1)
else:
    if (V-A) % (A-B) == 0:
        print((V-A)//(A-B)+1)
    else:
        print((V-A)//(A-B)+2)


# ----------------------------------
# https://school.programmers.co.kr/learn/courses/30/lessons/12940
# 최대공약수와 최소공배수
# 문제 설명
# 두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환하는 함수, solution을 완성해 보세요. 배열의 맨 앞에 최대공약수, 그다음 최소공배수를 넣어 반환하면 됩니다.
# 예를 들어 두 수 3, 12의 최대공약수는 3, 최소공배수는 12이므로 solution(3, 12)는 [3, 12]를 반환해야 합니다.
# 제한 사항
# 두 수는 1이상 1000000이하의 자연수입니다.

# 최대공약수는 자신보다 클수 없다. 최소 공배수는 자신과 같거나 크다.
n = 3
m = 12

list = []
# 최대공약수 구하기
# 둘 중 작은 수의 약수들 중 가장 큰 공약수 구하기
for i in range(min(n, m), 0, -1):
    if n % i == 0 and m % i == 0:
        list.append(i)
        break

# 최소공배수 구하기
# 최소공배수는 두수의 곱보다 클 수 없다.
for i in range(1, n*m+1):
    if i % n == 0 and i % m == 0:
        list.append(i)
        break

# 최소공배수는 두수의 곱을 최대공약수로 나눈 값과 같다.
lcm = (n*m)//list[0]

# 최종 함수


def solution(n, m):
    answer = []
    for i in range(min(n, m), 0, -1):
        if n % i == 0 and m % i == 0:
            answer.append(i)
            break
    answer.append((n*m)//answer[0])
    return answer
