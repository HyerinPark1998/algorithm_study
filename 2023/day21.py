# https://www.acmicpc.net/problem/2745
# 진법 변환
# 문제
# B진법 수 N이 주어진다. 이 수를 10진법으로 바꿔 출력하는 프로그램을 작성하시오.
# 10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.
# A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35
# 입력
# 첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36)
# B진법 수 N을 10진법으로 바꾸면, 항상 10억보다 작거나 같다.
# 출력
# 첫째 줄에 B진법 수 N을 10진법으로 출력한다.

# 2진수를 10진수를 바꿀 때, 1010 -> (1*2**3)+(0*2**2)+(1*2**1)+(0*2**0)
# 각 숫자와 그 숫자의 인덱스를 가지고 계산을한다.
# 그렇다면 필요한 정보는 몇진법인지, 무슨 숫자인지, 그리고 그 숫자의 자릿값이다.

# 문제에서 10진법을 넘어가는 진법은 영어 대문자를 이용하여 표현한다고 한다.
# 각 알파벳에 해당하는 숫자를 딕셔너리로 만들어 찾아올 수도 있고, 아스키코드 변환함수를 이용하여 숫자를 가져올수도 있을 것 같다.
# 딕셔너리를 일일이 입력하기 힘드니 아스키코드 변환함수를 사용하겠다. ord(문자)-> 정수 / chr(정수) -> 문자
# B진법 수 N
N, B = input().split()

# 10진법을 넘어갈 때와 안넘어갈 때의 구분이 필요할까?
# 생각을 더 해본 결과 0부터 Z까지 나열된 한 문장이나 리스트를 만들어 그 단어의 인덱스값을 갖고 오면 될것같다!

numbers = '123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
# 제곱의 숫자는 뒤에서부터 0으로 시작하기 때문에 N의 순서를 거꾸로 만든다음 for문으로 계산을 해주자
N = N[::-1]
result = 0
for i, n in enumerate(N):
    n = numbers.index(n)+1  # 인덱스는 0부터 시작하므로 문자에 해당하는 숫자를 얻을려면 더하기 1해주자
    result += (n*int(B)**i)

print(result)

# ValueError가 발생하였다. 왜일까?
# 인풋값으로 1010 2을 주니 오류가 발생하였다. ValueError: substring not found
# 아 numbers에 0을 넣어주지 않았다. 다시금 코드를 수정해보자. 0이 들어감으로써 index에 1을 더해줄 필요도 사라졌다.
numbers = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'

N = N[::-1]
result = 0
for i, n in enumerate(N):
    n = numbers.index(n)
    result += (n*int(B)**i)

print(result)


# ----------------------------------
# https://www.acmicpc.net/problem/11005
# 진법 변환2
# 문제
# 10진법 수 N이 주어진다. 이 수를 B진법으로 바꿔 출력하는 프로그램을 작성하시오.
# 10진법을 넘어가는 진법은 숫자로 표시할 수 없는 자리가 있다. 이런 경우에는 다음과 같이 알파벳 대문자를 사용한다.
# A: 10, B: 11, ..., F: 15, ..., Y: 34, Z: 35
# 입력
# 첫째 줄에 N과 B가 주어진다. (2 ≤ B ≤ 36) N은 10억보다 작거나 같은 자연수이다.
# 출력
# 첫째 줄에 10진법 수 N을 B진법으로 출력한다.

# 위의 문제는 B진법 -> 10진법이었다면 이번에는 10진법 -> B진법이다.
# 자 보통 10진법을 2진법으로 할 때 어떻게 만들었나? 10진수를 2로 나눈 나머지를 기록하고 몫을 계속 나눠주는 것을 반복했다.
N, B = map(int, input().split())
numbers = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'

# 그러면 똑같이 가보자 나누고 기록하고 나누고 기록하고
# 전에 배운 재귀함수로 코드를 짜보았다.


def solution(N, B):
    n = N // B
    num = N % B
    # 몫이 0이 되었을 때 함수를 빠져나갈 수 있도록 장치
    if n == 0:
        num = N % B
        return numbers[num]
    return solution(n, B)+numbers[num]


print(solution(N, B))
